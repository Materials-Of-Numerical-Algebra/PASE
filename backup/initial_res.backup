#if 0
      /* 判断是否已经达到较好的初始精度 */
      if (level < num_levels-2 && level > 0)
      {
	 /* 此时pvx是level-1层的特征向量 */
	 if (level == 1)
	 {
	    /* 计算残量 */
	    HYPRE_ParCSRMatrixMatvec ( 1.0, B_array[0], pvx[block_size-more-1], 0.0, F_array[0] );
	    HYPRE_ParVectorInnerProd (F_array[0], pvx[block_size-more-1], &tmp_double);
	    HYPRE_ParCSRMatrixMatvec ( 1.0, A_array[0], pvx[block_size-more-1], -eigenvalues[block_size-more-1], F_array[0] );
	    HYPRE_ParVectorInnerProd (F_array[0], F_array[0], &residual);
	    residual = sqrt(residual/tmp_double);
	 }
	 else 
	 {
	    HYPRE_ParCSRMatrixMatvec ( 1.0, P_array[level-2], pvx[block_size-more-1], 0.0, U_array[level-2]);
	    for (i = level-3; i >= 0; --i)
	    {
	       HYPRE_ParCSRMatrixMatvec ( 1.0, P_array[i], U_array[i+1], 0.0, U_array[i] );
	    }
	    /* 计算残量 */
	    HYPRE_ParCSRMatrixMatvec ( 1.0, B_array[0], U_array[0], 0.0, F_array[0] );
	    HYPRE_ParVectorInnerProd (F_array[0], U_array[0], &tmp_double);
	    HYPRE_ParCSRMatrixMatvec ( 1.0, A_array[0], U_array[0], -eigenvalues[block_size-more-1], F_array[0] );
	    HYPRE_ParVectorInnerProd (F_array[0], F_array[0], &residual);
	    residual = sqrt(residual/tmp_double);
	 }
	 if (myid==0)
	 {
	    printf ( "inital maximal residual = %f\n", residual );
	 }
	 if ( residual < initial_res )
	 {
	    /* 将所有特征向量插值到最细空间 */
	    if (level == 1)
	    {
	       /* 特征向量已经在最细层 */
	    }
	    else 
	    {
	       eigenvectors_h = 
		  mv_MultiVectorCreateFromSampleVector(interpreter, block_size, U_array[0]);
	       mv_TempMultiVector* tmp = 
		  (mv_TempMultiVector*) mv_MultiVectorGetData(eigenvectors_h);
	       pvx_pre = (HYPRE_ParVector*)(tmp -> vector);

	       if (level == 2)
	       {
		  for (idx_eig = 0; idx_eig < block_size; ++idx_eig)
		  {
		     HYPRE_ParCSRMatrixMatvec ( 1.0, P_array[level-2], pvx[idx_eig], 0.0, pvx_pre[idx_eig]);
		  }
	       }
	       else 
	       {
		  for (idx_eig = 0; idx_eig < block_size; ++idx_eig)
		  {
		     HYPRE_ParCSRMatrixMatvec ( 1.0, P_array[level-2], pvx[idx_eig], 0.0, U_array[level-2]);
		     for (i = level-3; i > 0; --i)
		     {
			HYPRE_ParCSRMatrixMatvec ( 1.0, P_array[i], U_array[i+1], 0.0, U_array[i] );
		     }
		     HYPRE_ParCSRMatrixMatvec ( 1.0, P_array[0], U_array[1], 0.0, pvx_pre[idx_eig] );
		  }
	       }
	       /* 销毁 */
	       for (idx_eig = 0; idx_eig < block_size; ++idx_eig)
	       {
		  HYPRE_ParVectorDestroy(pvx[idx_eig]);
	       }
	       hypre_TFree(pvx);
	       free((mv_TempMultiVector*) mv_MultiVectorGetData(eigenvectors));
	       hypre_TFree(eigenvectors);
	       /* pvx_pre是当前层更新的特征向量 */
	       pvx = pvx_pre;
	       eigenvectors = eigenvectors_h;
	    }
	    break;
	 }
      }
#endif
